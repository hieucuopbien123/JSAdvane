JSAdvance



# Stylecode
-> So sánh if else và switch case:
if else là cấu trúc bậc thang
switch case nhanh hơn if else đáng kể khi số lượng điều kiện lớn. Do mỗi điều kiện k phụ thuộc vào điều kiện trước đó nên dùng cấu trúc cây rẽ nhánh để thực hiện song song như trong mạch logic ấy sẽ nhanh hơn.
=> Tuy nhiên trong Js khi muốn search theo key nên dùng new Map là nhanh nhất. Map là 1 instanceof Object nhưng sinh ra để search nhanh hơn



# Datatype trong JS
Kiểu dữ liệu nguyên thủy là kiểu kích thước cố định nên đơn giản và cải thiện tốc độ truy vấn biến. Do đó được lưu trong ngăn xếp cố định nên truy cập theo giá trị.
Kiểu dữ liệu tham chiếu là kiểu có kích thước thay đổi nên k được lưu trữ trong ngăn xếp cố định mà phải lưu trên heap và truy cập theo địa chỉ reference nên tốc độ truy vấn biến chậm hơn. Như array, object,...

-> K dùng typeof (cho frontend)



# Design pattern JS



# Class trong JS



# NodeJS



# MongoDB Pattern



# Frontend



# LRU cache
Trong JS có WeakMap và WeakSet và WeakRef giúp giải phóng bộ nhớ reference tót hơn khi không sử dụng.
Nhưng đối với bộ nhớ đệm từ xa thì k nên vì dữ liệu từ xa có thể bị xóa khỏi đệm 1 cách khó lường mà bên gọi không biết. Khi đó tốt nhất là sử dụng LRU cache

Bộ cache giói hạn giá trị. VD 10 giá trị chẳng hạn. Thì khi thêm vào cache giá trị thứ 11, nó sẽ tự xóa cái Least Recent Used.
Implement LRU cache trong JS: https://medium.com/dsinjs/implementing-lru-cache-in-javascript-94ba6755cda9



# Nên lưu JWT ở localStorage hay cookie với serverless
CMS (Content Management System) là hệ thống quản trị nội dung. VD ta quản lý text, video, ảnh các thứ bằng CMS chẳng hạn. Nó khác với 1 cái store bth ở chỗ nó dùng để quản lý tài nguyên trên trang web. 1 CMS tốt sẽ cho phép quản lý website hoàn toàn bằng giao diện mà k cần code. VD như wordpress, admin có thể vào quản lý tài nguyên trang web hay tạo các thành phần web hoàn toàn bằng giao diện và là serverless luôn.
Strapi là 1 CMS giúp tạo serverless. Ta có thể vào tạo ra data bằng giao diện và nó tự tạo RESTful API hoặc GraphQL để tương tác luôn mà k cần code.

CSRF (Cross site request forgery) là kiểu tấn công ta ấn vào link trang web này thì bị redirect đến 1 trang web khác đã đăng nhập và thực hiện lệnh k mong muốn
=> ref tới "NodeJS / Module bảo mật server nodejs" giải thích chuẩn hơn
XSS là lợi dụng input html vào web để lấy các thông tin bằng JS.

CSRF chống tốt nhất là Double Submit Cookie bằng cách lưu 1 trường random vào cookie và yêu cầu gửi kèm. Action chỉ thực hiện khi giá trị trong cookie là đúng. Nếu tấn công như trên gọi từ trang web A vào trang web B sẽ k có trường random trong cookie tương ứng gửi kèm nên k thực hiện được => được nhé vì webA gọi API tới webB sẽ k có cookie đó (chứ kp là webA redirect sang tab mới webB nhé vì redirect thì chả sao cả)
XSS thì mỗi vị trí input đều phải chống, biến input thành params chứ kp điền vào chỗ trống rồi replace nữa.

=> Nhiều căn cứ cho thấy nên dùng cookie hơn vì httpOnly giúp cookie không thể truy cập bằng XSS mà chỉ thông qua http API, còn SameSite=Strict Secure giúp ngăn gửi cookie trong mọi cross-site khác. 

Khi dùng localStorage thì phải chống XSS attack ở mọi nơi. Còn khi dùng cookie đã tự bảo vệ dữ liệu trong cookie khỏi XSS nhờ httpOnly rồi, nhưng ta lại phải chống CRSF attack
Để chống CSRF attack thì client cần lưu CSRF token. Có nhiều cách lưu:
- Lưu trong 1 biến JS: cách này được nhưng k hay vì lại phải chống XSS attack cản người dùng truy cập vào biến đó.
- Lưu trong cookie (có httpOnly), server sẽ lấy từ cookie ra check => cách này hay vì cũng tự cản XSS attack
- Lưu là data của 1 hidden form field
- Ghi vào code JS gửi qua 1 custom header, VD: X-CSRF-Token => cần cản người dùng truy cập được file js thuần đó



# Other
-> NodeJS có cli:
node -> http.STATUS_CODES
        Date.now()

-> Kp lúc nào ta cũng dùng hết các PP bảo mật trong 1 dự án.
Token JWT
Rate limit: Hạn chế 1 token chỉ được request tới server n lần/x phút
Dùng đủ cors headers

Timestamp mechanism: cơ chế chống replicate attack và DDoS (nhưng không mạnh). VD ta cấm 1 request được lặp lại trong quá 1p.
Nonce: Cơ chế chống replicate attack. Server lưu thêm nonce và nếu 1 nonce từng được sử dụng sẽ lỗi luôn.
=> ref tới "# Bảo mật server nodejs"

Signature Generation: VD MITM bắt request chuyển tiền và sửa payload người nhận thành hacker. Giải pháp này là ký cái payload bằng khóa của người dùng thì nếu hacker đổi payload sẽ k khớp với sig nữa, lại phải có cơ chế riêng bảo mật khóa để ký (hoặc lưu local máy người dùng mỗi khi login). 
Các ứng dụng thường dùng giải pháp an toàn như gửi qua mail hay VD trong app ngân hàng nó thường gửi thẳng OTP về điện thoại, google authen

BlackList: Cho người dùng hoặc IP nào spam vào blacklist cấm luôn, Vd khi 1 người dùng gửi quá nhiều request trong 10s liên tiếp. Có thể lưu vào redis chẳng hạn.
WhiteList: cấm mọi thứ trừ các IP và user trong whitelist

